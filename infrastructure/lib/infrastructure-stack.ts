import * as path from 'path';
import { Construct, IConstruct } from 'constructs';
import * as cdk from 'aws-cdk-lib';
import * as cdk_nag from 'cdk-nag';
import * as ec2 from "aws-cdk-lib/aws-ec2";
import * as ecs from "aws-cdk-lib/aws-ecs";
import * as ssm from "aws-cdk-lib/aws-ssm";
import * as ecr_assets from "aws-cdk-lib/aws-ecr-assets";
import * as ecs_patterns from "aws-cdk-lib/aws-ecs-patterns";
import * as elb from "aws-cdk-lib/aws-elasticloadbalancingv2";
import * as iam from "aws-cdk-lib/aws-iam";
import * as s3 from "aws-cdk-lib/aws-s3";
import * as logs from "aws-cdk-lib/aws-logs";
import * as lambda from "aws-cdk-lib/aws-lambda";
import * as customresource from "aws-cdk-lib/custom-resources";
import * as cloudfront from "aws-cdk-lib/aws-cloudfront";
import * as origins from "aws-cdk-lib/aws-cloudfront-origins";
import * as dynamodb from 'aws-cdk-lib/aws-dynamodb';
import * as opensearch from 'aws-cdk-lib/aws-opensearchservice';
import * as wafv2 from 'aws-cdk-lib/aws-wafv2';

// AI Service Construct
import { AiService } from "./ai-service";
import * as elbv2 from "aws-cdk-lib/aws-elasticloadbalancingv2";

// CDK Aspect to apply NAG suppressions after resources are created
class OpenSearchNagSuppressionsAspect implements cdk.IAspect {
    visit(node: IConstruct): void {
        const nodePath = node.node.path;
        
        // Apply suppressions to all auto-generated Lambda functions for OpenSearch logging
        if (node instanceof lambda.CfnFunction) {
            const functionName = node.functionName;
            // Check if this is an auto-generated Lambda for OpenSearch logging
            if ((functionName && typeof functionName === 'string' && functionName.startsWith('AWS') && functionName.length > 30) ||
                nodePath.includes('AWS679f53fac002430cb0da5b7982bd2287') ||
                nodePath.includes('ProductsDomain')) {
                cdk_nag.NagSuppressions.addResourceSuppressions(node, [
                    { id: "AwsSolutions-L1", reason: "Auto-generated Lambda function for OpenSearch logging runtime is managed by CDK and cannot be customized." }
                ]);
            }
        }
        
        // Apply suppressions to all auto-generated IAM roles for OpenSearch logging
        if (node instanceof iam.CfnRole) {
            const roleName = node.roleName;
            // Check if this is an auto-generated role for OpenSearch logging
            if ((roleName && typeof roleName === 'string' && roleName.startsWith('AWS') && roleName.length > 30) ||
                nodePath.includes('AWS679f53fac002430cb0da5b7982bd2287') ||
                nodePath.includes('ProductsDomain') ||
                nodePath.includes('ServiceRole')) {
                cdk_nag.NagSuppressions.addResourceSuppressions(node, [
                    { id: "AwsSolutions-IAM4", reason: "Auto-generated Lambda function for OpenSearch logging uses AWSLambdaBasicExecutionRole managed policy. This is automatically created by CDK and cannot be customized.", appliesTo: ['Policy::arn:<AWS::Partition>:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole'] }
                ]);
            }
        }

        // Apply suppressions to all auto-generated IAM policies for OpenSearch logging
        if (node instanceof iam.CfnPolicy) {
            const policyName = node.policyName;
            // Check if this is an auto-generated policy for OpenSearch logging
            if ((policyName && typeof policyName === 'string' && 
                (policyName.includes('CustomResourcePolicy') || 
                 policyName.includes('ESLogGroupPolicy') ||
                 (policyName.startsWith('AWS') && policyName.length > 30))) ||
                nodePath.includes('ProductsDomain') ||
                nodePath.includes('ESLogGroupPolicy') ||
                nodePath.includes('CustomResourcePolicy')) {
                cdk_nag.NagSuppressions.addResourceSuppressions(node, [
                    { id: "AwsSolutions-IAM5", reason: "OpenSearch logging custom resource requires wildcard permissions to manage CloudWatch log groups. This is automatically generated by CDK for OpenSearch logging functionality.", appliesTo: ['Resource::*'] }
                ]);
            }
        }

        // Apply suppressions to any custom resource policies related to OpenSearch
        if (node instanceof iam.CfnManagedPolicy) {
            if (nodePath.includes('ProductsDomain') ||
                nodePath.includes('ESLogGroupPolicy') ||
                nodePath.includes('CustomResourcePolicy')) {
                cdk_nag.NagSuppressions.addResourceSuppressions(node, [
                    { id: "AwsSolutions-IAM5", reason: "OpenSearch logging custom resource requires wildcard permissions to manage CloudWatch log groups. This is automatically generated by CDK for OpenSearch logging functionality.", appliesTo: ['Resource::*'] }
                ]);
            }
        }

        // Catch-all for any remaining OpenSearch-related resources and specific AWS Lambda function
        if (nodePath.includes('ProductsDomain') || nodePath.includes('AWS679f53fac002430cb0da5b7982bd2287')) {
            // Apply generic suppressions for common NAG violations in OpenSearch auto-generated resources
            if (node.node.defaultChild) {
                const cfnResource = node.node.defaultChild as cdk.CfnResource;
                if (cfnResource.cfnResourceType === 'AWS::IAM::Policy' || 
                    cfnResource.cfnResourceType === 'AWS::IAM::ManagedPolicy') {
                    cdk_nag.NagSuppressions.addResourceSuppressions(cfnResource, [
                        { id: "AwsSolutions-IAM5", reason: "OpenSearch logging custom resource requires wildcard permissions to manage CloudWatch log groups. This is automatically generated by CDK for OpenSearch logging functionality.", appliesTo: ['Resource::*'] }
                    ]);
                }
                if (cfnResource.cfnResourceType === 'AWS::IAM::Role') {
                    cdk_nag.NagSuppressions.addResourceSuppressions(cfnResource, [
                        { id: "AwsSolutions-IAM4", reason: "Auto-generated Lambda function for OpenSearch logging uses AWSLambdaBasicExecutionRole managed policy. This is automatically created by CDK and cannot be customized.", appliesTo: ['Policy::arn:<AWS::Partition>:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole'] }
                    ]);
                }
                if (cfnResource.cfnResourceType === 'AWS::Lambda::Function') {
                    cdk_nag.NagSuppressions.addResourceSuppressions(cfnResource, [
                        { id: "AwsSolutions-L1", reason: "Auto-generated Lambda function for OpenSearch logging runtime is managed by CDK and cannot be customized." }
                    ]);
                }
            }
        }

        // Additional specific targeting for the AWS679f53fac002430cb0da5b7982bd2287 Lambda function and its ServiceRole
        if (nodePath.includes('AWS679f53fac002430cb0da5b7982bd2287')) {
            // Direct suppression for the Lambda function resource
            if (node.node.defaultChild && (node.node.defaultChild as cdk.CfnResource).cfnResourceType === 'AWS::Lambda::Function') {
                cdk_nag.NagSuppressions.addResourceSuppressions(node.node.defaultChild as cdk.CfnResource, [
                    { id: "AwsSolutions-L1", reason: "Auto-generated Lambda function for OpenSearch logging runtime is managed by CDK and cannot be customized." }
                ]);
            }
            
            // Direct suppression for the ServiceRole
            if (nodePath.includes('ServiceRole') && node.node.defaultChild && (node.node.defaultChild as cdk.CfnResource).cfnResourceType === 'AWS::IAM::Role') {
                cdk_nag.NagSuppressions.addResourceSuppressions(node.node.defaultChild as cdk.CfnResource, [
                    { id: "AwsSolutions-IAM4", reason: "Auto-generated Lambda function for OpenSearch logging uses AWSLambdaBasicExecutionRole managed policy. This is automatically created by CDK and cannot be customized.", appliesTo: ['Policy::arn:<AWS::Partition>:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole'] }
                ]);
            }
        }

        // Specific targeting for OpenSearchServiceRoleProvider DefaultPolicy
        if (nodePath.includes('OpenSearchServiceRoleProvider') && nodePath.includes('DefaultPolicy')) {
            if (node instanceof iam.CfnPolicy) {
                cdk_nag.NagSuppressions.addResourceSuppressions(node, [
                    { 
                        id: "AwsSolutions-IAM5", 
                        reason: "Custom resource provider DefaultPolicy requires wildcard permissions to invoke Lambda function versions. This is automatically generated by CDK for Lambda function versioning and aliases. The wildcard is scoped to the specific OpenSearch service role function ARN to maintain security while allowing version-specific invocations.",
                        appliesTo: ['Resource::*'] 
                    }
                ]);
            }
            
            if (node.node.defaultChild && (node.node.defaultChild as cdk.CfnResource).cfnResourceType === 'AWS::IAM::Policy') {
                cdk_nag.NagSuppressions.addResourceSuppressions(node.node.defaultChild as cdk.CfnResource, [
                    { 
                        id: "AwsSolutions-IAM5", 
                        reason: "Custom resource provider DefaultPolicy requires wildcard permissions to invoke Lambda function versions. This is automatically generated by CDK for Lambda function versioning and aliases. The wildcard is scoped to the specific OpenSearch service role function ARN to maintain security while allowing version-specific invocations.",
                        appliesTo: ['Resource::*'] 
                    }
                ]);
            }
        }
    }
}

export class CxAppStack extends cdk.Stack {

    public readonly Distribution: cloudfront.Distribution

    constructor(scope: Construct, id: string, props: cdk.StackProps) {
        super(scope, id, props)

        // Common IAM policy for logging
        const logPolicy = new iam.ManagedPolicy(this, "LogsPolicy", {
            statements: [
                new iam.PolicyStatement({
                    sid: "Logs",
                    effect: iam.Effect.ALLOW,
                    actions: [
                        "logs:CreateLogGroup",
                        "logs:CreateLogStream",
                        "logs:PutLogEvents",
                        "logs:DescribeLogGroups",
                        "logs:DescribeLogStreams"],
                    resources: ["*"]
                }),
            ]
        })

        // Suppress CDK-Nag for logs resources
        cdk_nag.NagSuppressions.addResourceSuppressions(logPolicy, [
            { id: "AwsSolutions-IAM5", reason: "Suppress rule for Resource:* on CloudWatch logs related actions" }
        ])

        // Create VPC for hosting React application in ECS
        const vpc = new ec2.Vpc(this, "Vpc", {
            maxAzs: 3,
            ipAddresses: ec2.IpAddresses.cidr("10.1.0.0/16"),
            vpcName: `${cdk.Stack.of(this).stackName}-vpc`,
            restrictDefaultSecurityGroup: false, // Disable the default security group restriction
        })

        // IAM Role for VPC Flow Logs
        const vpcFlowLogsRole = new iam.Role(this, "VpcFlowLogsRole", {
            roleName: `${cdk.Stack.of(this).stackName}-${cdk.Stack.of(this).region}-vpc-flow-logs-role`,
            assumedBy: new iam.ServicePrincipal("vpc-flow-logs.amazonaws.com"),
            managedPolicies: [logPolicy],
        })

        // Flow logs log group
        const flowLogs = new logs.LogGroup(this, "VpcFlowLogsLogGroup", {
            logGroupName: `${cdk.Stack.of(this).stackName}-vpc-flow-logs`,
            removalPolicy: cdk.RemovalPolicy.DESTROY,
        })

        vpc.addFlowLog("FlowLog", {
            destination: ec2.FlowLogDestination.toCloudWatchLogs(flowLogs, vpcFlowLogsRole),
            trafficType: ec2.FlowLogTrafficType.ALL
        })

        // IAM role for Lambda function custom resource that will retrieve CloudFront prefix list id
        const lambdaRole = new iam.Role(this, "LambdaRole", {
            roleName: `${cdk.Stack.of(this).stackName}-${cdk.Stack.of(this).region}-cr-pl-role`,
            assumedBy: new iam.ServicePrincipal("lambda.amazonaws.com"),
            managedPolicies: [logPolicy],
            inlinePolicies: {
                policy: new iam.PolicyDocument({
                    statements: [
                        new iam.PolicyStatement({
                            sid: "Ec2Describe",
                            effect: iam.Effect.ALLOW,
                            actions: ["ec2:DescribeManagedPrefixLists"],
                            resources: ["*"]
                        }),
                    ]
                })
            },
        })
        // Suppress CDK-Nag for Resources:*
        cdk_nag.NagSuppressions.addResourceSuppressions(lambdaRole, [
            { id: "AwsSolutions-IAM5", reason: "ec2 Describe permissions require all resources." },
        ])

        // Lambda function to retrieve CloudFront prefix list id
        const lambdaFunction = new lambda.Function(this, "LambdaFunction", {
            code: lambda.Code.fromAsset(path.join(__dirname, './lambda')),
            handler: "prefix_list.lambda_handler",
            runtime: lambda.Runtime.PYTHON_3_14,
            timeout: cdk.Duration.minutes(1),
            role: lambdaRole,
            description: "Custom resource Lambda function",
            functionName: `${cdk.Stack.of(this).stackName}-custom-resource-lambda`,
            logGroup: new logs.LogGroup(this, "LambdaLogGroup", {
                logGroupName: `/aws/lambda/${cdk.Stack.of(this).stackName}-custom-resource-lambda`,
                removalPolicy: cdk.RemovalPolicy.DESTROY,
            }),
        })

        // IAM role for Lambda function custom resource that will retrieve CloudFront prefix list id
        const prefixListLambdaCustomResource = new iam.Role(this, "PrefixCustomResourceLambdaRole", {
            roleName: `${cdk.Stack.of(this).stackName}-${cdk.Stack.of(this).region}-pl-cr-role`,
            assumedBy: new iam.ServicePrincipal("lambda.amazonaws.com"),
            managedPolicies: [logPolicy],
            inlinePolicies: {
                policy: new iam.PolicyDocument({
                    statements: [
                        new iam.PolicyStatement({
                            sid: "LambdaInvoke",
                            effect: iam.Effect.ALLOW,
                            actions: ["lambda:InvokeFunction"],
                            resources: [lambdaFunction.functionArn]
                        }),
                    ]
                })
            },
        })

        // Create custom resource using lambda function
        const customResourceProvider = new customresource.Provider(this, "CustomResourceProvider", {
            onEventHandler: lambdaFunction,
            logGroup: new logs.LogGroup(this, "CustomResourceLambdaLogs", {
                removalPolicy: cdk.RemovalPolicy.DESTROY
            }),
            role: prefixListLambdaCustomResource
        })

        const prefixListResponse = new cdk.CustomResource(this, 'CustomResource', { serviceToken: customResourceProvider.serviceToken });

        // Suppress CDK-Nag for Resources:*
        cdk_nag.NagSuppressions.addResourceSuppressions(customResourceProvider, [
            { id: "AwsSolutions-L1", reason: "Custom resource onEvent Lambda runtime is not in our control. Hence suppressing the warning." },
        ], true)
        cdk_nag.NagSuppressions.addResourceSuppressions(prefixListLambdaCustomResource, [
            { id: "AwsSolutions-IAM5", reason: "Custom resource adds permissions that we have no control over. Hence suppressing the warning." }
        ], true)

        const prefixList = prefixListResponse.getAttString("PrefixListId")

        // Data source S3 bucket
        const bucket = new s3.Bucket(this, "DataSourceBucket", {
            bucketName: `${cdk.Stack.of(this).stackName.toLowerCase()}-data-source-${cdk.Aws.ACCOUNT_ID}-${cdk.Aws.REGION}`,
            autoDeleteObjects: true,
            encryption: s3.BucketEncryption.S3_MANAGED,
            removalPolicy: cdk.RemovalPolicy.DESTROY,
            enforceSSL: true,
        })

        cdk_nag.NagSuppressions.addResourceSuppressions(bucket, [
            { id: "AwsSolutions-S1", reason: "Access logging is not enabled for this bucket since this is the only bucket being provisioned by the stack." }
        ])

        // ECS tasks IAM Role
        const ecsTaskIamRole = new iam.Role(this, "EcsTaskRole", {
            roleName: `${cdk.Stack.of(this).stackName}-${cdk.Stack.of(this).region}-ecs-tasks-role`,
            assumedBy: new iam.ServicePrincipal("ecs-tasks.amazonaws.com"),
            managedPolicies: [logPolicy],
            inlinePolicies: {
                policy: new iam.PolicyDocument({
                    statements: [
                        new iam.PolicyStatement({
                            sid: "SSMMessages",
                            effect: iam.Effect.ALLOW,
                            actions: [
                                "ssmmessages:CreateControlChannel",
                                "ssmmessages:CreateDataChannel",
                                "ssmmessages:OpenControlChannel",
                                "ssmmessages:OpenDataChannel"
                            ],
                            resources: ["*"]
                        }),
                        new iam.PolicyStatement({
                            sid: "S3Permissions",
                            effect: iam.Effect.ALLOW,
                            actions: [
                                "s3:List*",
                                "s3:PutObject*",
                                "s3:GetObject",
                                "s3:DeleteObject"
                            ],
                            resources: [
                                `${bucket.bucketArn}`,
                                `${bucket.bucketArn}*`,
                            ]
                        }),
                        new iam.PolicyStatement({
                            sid: "ECRImage",
                            effect: iam.Effect.ALLOW,
                            actions: ["ecr:BatchCheckLayerAvailability", "ecr:GetDownloadUrlForLayer", "ecr:BatchGetImage"],
                            resources: [`arn:${cdk.Stack.of(this).partition}:ecr:${cdk.Stack.of(this).region}:${cdk.Stack.of(this).account}:repository/${cdk.DefaultStackSynthesizer.DEFAULT_IMAGE_ASSETS_REPOSITORY_NAME}`]
                        }),
                        new iam.PolicyStatement({
                            sid: "ECRAuth",
                            effect: iam.Effect.ALLOW,
                            actions: ["ecr:GetAuthorizationToken"],
                            resources: ["*"]
                        })
                    ]
                })
            }
        })

        // Suppress CDK-Nag for Resources:*
        cdk_nag.NagSuppressions.addResourceSuppressions(ecsTaskIamRole, [
            { id: "AwsSolutions-IAM5", reason: "ssm messages, bedrock and retrieve ECR auth permissions require all resources." },
        ], true)

        // ECS cluster for hosting React & Strands applications
        const cluster = new ecs.Cluster(this, "EcsCluster", {
            vpc: vpc,
            clusterName: `${cdk.Stack.of(this).stackName}-ecs`,
            containerInsights: true,
        })

        // Build image and store in ECR
        const image = ecs.ContainerImage.fromAsset(path.join(__dirname, '../../frontend'), { platform: ecr_assets.Platform.LINUX_ARM64 })

        // Load balancer resources 
        const elbSg = new ec2.SecurityGroup(this, "LoadBalancerSecurityGroup", {
            vpc: vpc,
            allowAllOutbound: true,
            description: "Security group for ALB",
        })
        elbSg.addIngressRule(ec2.Peer.prefixList(prefixList), ec2.Port.tcp(80), "Enable 80 IPv4 ingress from CloudFront")

        const alb = new elb.ApplicationLoadBalancer(this, "ALB", {
            vpc: vpc,
            securityGroup: elbSg,
            internetFacing: true,
            loadBalancerName: `${cdk.Stack.of(this).stackName}-alb`,
        })

        // Suppress CDK-Nag for ALB access logging
        cdk_nag.NagSuppressions.addResourceSuppressions(alb, [
            { id: "AwsSolutions-ELB2", reason: "ALB access logging is not enabled to demo purposes." },
        ], true)

        // Create Origin Access Control for S3 using CloudFormation
        const originAccessControl = new cloudfront.CfnOriginAccessControl(this, "S3OriginAccessControl", {
            originAccessControlConfig: {
                name: `${cdk.Stack.of(this).stackName}-${cdk.Stack.of(this).region}-s3-oac`,
                description: `OAC for ${cdk.Stack.of(this).stackName} S3 bucket in ${cdk.Stack.of(this).region}`,
                originAccessControlOriginType: "s3",
                signingBehavior: "always",
                signingProtocol: "sigv4",
            },
        })

        // Create WAF v2 Web ACL with AWS Managed Rules for CloudFront
        // Note: For now, we'll only create WAF if we're in us-east-1 region
        // CloudFront WAF must be created in us-east-1 region
        let webAclArn: string | undefined;
        
        if (cdk.Stack.of(this).region === 'us-east-1') {
            const webAcl = new wafv2.CfnWebACL(this, "CloudFrontWebACL", {
                name: `${cdk.Stack.of(this).stackName}-cloudfront-waf`,
                description: "WAF Web ACL for CloudFront distribution with AWS Managed Rules",
                scope: "CLOUDFRONT", // Required for CloudFront
                defaultAction: {
                    allow: {} // Allow requests by default, block based on rules
                },
                rules: [
                    {
                        name: "AWSManagedRulesCommonRuleSet",
                        priority: 1,
                        overrideAction: {
                            none: {} // Use the rule group's configured action
                        },
                        statement: {
                            managedRuleGroupStatement: {
                                vendorName: "AWS",
                                name: "AWSManagedRulesCommonRuleSet"
                            }
                        },
                        visibilityConfig: {
                            sampledRequestsEnabled: true,
                            cloudWatchMetricsEnabled: true,
                            metricName: "CommonRuleSetMetric"
                        }
                    },
                    {
                        name: "AWSManagedRulesKnownBadInputsRuleSet",
                        priority: 2,
                        overrideAction: {
                            none: {}
                        },
                        statement: {
                            managedRuleGroupStatement: {
                                vendorName: "AWS",
                                name: "AWSManagedRulesKnownBadInputsRuleSet"
                            }
                        },
                        visibilityConfig: {
                            sampledRequestsEnabled: true,
                            cloudWatchMetricsEnabled: true,
                            metricName: "KnownBadInputsRuleSetMetric"
                        }
                    },
                    {
                        name: "AWSManagedRulesAmazonIpReputationList",
                        priority: 3,
                        overrideAction: {
                            none: {}
                        },
                        statement: {
                            managedRuleGroupStatement: {
                                vendorName: "AWS",
                                name: "AWSManagedRulesAmazonIpReputationList"
                            }
                        },
                        visibilityConfig: {
                            sampledRequestsEnabled: true,
                            cloudWatchMetricsEnabled: true,
                            metricName: "AmazonIpReputationListMetric"
                        }
                    },
                    {
                        name: "AWSManagedRulesAnonymousIpList",
                        priority: 4,
                        overrideAction: {
                            none: {}
                        },
                        statement: {
                            managedRuleGroupStatement: {
                                vendorName: "AWS",
                                name: "AWSManagedRulesAnonymousIpList"
                            }
                        },
                        visibilityConfig: {
                            sampledRequestsEnabled: true,
                            cloudWatchMetricsEnabled: true,
                            metricName: "AnonymousIpListMetric"
                        }
                    }
                ],
                visibilityConfig: {
                    sampledRequestsEnabled: true,
                    cloudWatchMetricsEnabled: true,
                    metricName: `${cdk.Stack.of(this).stackName}WebAcl`
                }
            });
            
            webAclArn = webAcl.attrArn;
        } else {
            // When not in us-east-1, we cannot create CloudFront WAF in the same stack
            // Print a warning message
            new cdk.CfnOutput(this, "WAFWarning", {
                value: "WAF for CloudFront can only be created in us-east-1 region. Deploy this stack in us-east-1 to enable WAF protection.",
                description: "WAF deployment warning"
            });
        }

        // CloudFront distribution
        this.Distribution = new cloudfront.Distribution(this, "Distribution", {
            defaultBehavior: {
                origin: new origins.LoadBalancerV2Origin(alb, {
                    protocolPolicy: cloudfront.OriginProtocolPolicy.HTTP_ONLY,
                    customHeaders: {
                        "Header": "PRIVATE_ACCESS",
                        "AWS_DEPLOYMENT_REGION": cdk.Stack.of(this).region
                    },
                }),
                viewerProtocolPolicy: cloudfront.ViewerProtocolPolicy.REDIRECT_TO_HTTPS,
                allowedMethods: cloudfront.AllowedMethods.ALLOW_ALL,
                cachePolicy: cloudfront.CachePolicy.CACHING_DISABLED,
                originRequestPolicy: cloudfront.OriginRequestPolicy.ALL_VIEWER,
                compress: false,
            },
            additionalBehaviors: {
                "/images/*": {
                    origin: new origins.S3Origin(bucket, {
                        originAccessIdentity: undefined, // Use OAC instead of OAI
                    }),
                    viewerProtocolPolicy: cloudfront.ViewerProtocolPolicy.REDIRECT_TO_HTTPS,
                    allowedMethods: cloudfront.AllowedMethods.ALLOW_GET_HEAD,
                    cachePolicy: cloudfront.CachePolicy.CACHING_OPTIMIZED,
                    compress: true,
                },
            },
            minimumProtocolVersion: cloudfront.SecurityPolicyProtocol.TLS_V1_2_2021,
            comment: `${cdk.Stack.of(this).stackName}-${cdk.Stack.of(this).region}-cf-distribution`,
            enableLogging: false,
            webAclId: webAclArn, // Associate WAF with CloudFront (only if in us-east-1)
        })

        // Modify the CloudFront distribution to use OAC for S3 origin
        const cfnDistribution = this.Distribution.node.defaultChild as cloudfront.CfnDistribution
        cfnDistribution.addPropertyOverride('DistributionConfig.Origins.1.OriginAccessControlId', originAccessControl.attrId)
        cfnDistribution.addPropertyOverride('DistributionConfig.Origins.1.CustomOriginConfig', undefined)
        cfnDistribution.addPropertyOverride('DistributionConfig.Origins.1.S3OriginConfig', {
            OriginAccessIdentity: ''
        })

        // Add S3 bucket policy to allow CloudFront OAC access
        bucket.addToResourcePolicy(new iam.PolicyStatement({
            sid: "AllowCloudFrontServicePrincipal",
            effect: iam.Effect.ALLOW,
            principals: [new iam.ServicePrincipal("cloudfront.amazonaws.com")],
            actions: ["s3:GetObject"],
            resources: [`${bucket.bucketArn}/*`],
            conditions: {
                StringEquals: {
                    "AWS:SourceArn": `arn:aws:cloudfront::${cdk.Stack.of(this).account}:distribution/${this.Distribution.distributionId}`
                }
            }
        }))

        // Suppress CDK-Nag for CloudFront distribution
        cdk_nag.NagSuppressions.addResourceSuppressions(this.Distribution, [
            { id: "AwsSolutions-CFR1", reason: "Geo restrictions need to be applied when deployed in prod." },
            { id: "AwsSolutions-CFR3", reason: "CloudFront access logging is not enabled for demo purposes." },
            { id: "AwsSolutions-CFR4", reason: "We are not leveraging custom certificates." },
            { id: "AwsSolutions-CFR5", reason: "We are not leveraging custom certificates." },
            { id: "AwsSolutions-CFR7", reason: "CloudFront distribution now uses Origin Access Control (OAC) for S3 origin security." }
        ])

        // Custom managed policy for Lambda basic execution (replacing AWS managed policy)
        const lambdaBasicExecutionPolicy = new iam.ManagedPolicy(this, "LambdaBasicExecutionPolicy", {
            description: "Custom managed policy providing basic Lambda execution permissions",
            statements: [
                new iam.PolicyStatement({
                    sid: "CreateLogGroup",
                    effect: iam.Effect.ALLOW,
                    actions: ["logs:CreateLogGroup"],
                    resources: [`arn:${cdk.Stack.of(this).partition}:logs:${cdk.Stack.of(this).region}:${cdk.Stack.of(this).account}:*`]
                }),
                new iam.PolicyStatement({
                    sid: "LogStreamPermissions",
                    effect: iam.Effect.ALLOW,
                    actions: [
                        "logs:CreateLogStream",
                        "logs:PutLogEvents"
                    ],
                    resources: [
                        `arn:${cdk.Stack.of(this).partition}:logs:${cdk.Stack.of(this).region}:${cdk.Stack.of(this).account}:log-group:/aws/lambda/${cdk.Stack.of(this).stackName}-opensearch-slr-lambda:*`,
                        `arn:${cdk.Stack.of(this).partition}:logs:${cdk.Stack.of(this).region}:${cdk.Stack.of(this).account}:log-group:/aws/lambda/*Provider*:*`
                    ]
                })
            ]
        });

        // Suppress CDK-Nag for custom Lambda execution policy
        cdk_nag.NagSuppressions.addResourceSuppressions(lambdaBasicExecutionPolicy, [
            { 
                id: "AwsSolutions-IAM5", 
                reason: "Lambda execution policy requires wildcard permissions for log group creation and log stream operations across multiple Lambda functions. Resources are scoped to the current AWS account and region.",
                appliesTo: [
                    `Resource::arn:${cdk.Stack.of(this).partition}:logs:${cdk.Stack.of(this).region}:${cdk.Stack.of(this).account}:*`,
                    `Resource::arn:${cdk.Stack.of(this).partition}:logs:${cdk.Stack.of(this).region}:${cdk.Stack.of(this).account}:log-group:/aws/lambda/${cdk.Stack.of(this).stackName}-opensearch-slr-lambda:*`,
                    `Resource::arn:${cdk.Stack.of(this).partition}:logs:${cdk.Stack.of(this).region}:${cdk.Stack.of(this).account}:log-group:/aws/lambda/*Provider*:*`
                ]
            }
        ]);

        // IAM role for OpenSearch service-linked role Lambda function with custom managed policy
        const openSearchServiceRoleLambdaRole = new iam.Role(this, "OpenSearchServiceRoleLambdaRole", {
            roleName: `${cdk.Stack.of(this).stackName}-${cdk.Stack.of(this).region}-opensearch-slr-lambda-role`,
            assumedBy: new iam.ServicePrincipal("lambda.amazonaws.com"),
            managedPolicies: [lambdaBasicExecutionPolicy],
            inlinePolicies: {
                OpenSearchServiceRolePolicy: new iam.PolicyDocument({
                    statements: [
                        new iam.PolicyStatement({
                            sid: "ServiceLinkedRoleManagement",
                            effect: iam.Effect.ALLOW,
                            actions: [
                                'iam:CreateServiceLinkedRole',
                                'iam:GetRole',
                                'iam:ListRoles'
                            ],
                            resources: [
                                'arn:aws:iam::*:role/aws-service-role/opensearch.amazonaws.com/AWSServiceRoleForAmazonOpenSearchService'
                            ]
                        })
                    ]
                })
            }
        });

        // Suppress CDK-Nag for OpenSearch service-linked role permissions
        cdk_nag.NagSuppressions.addResourceSuppressions(openSearchServiceRoleLambdaRole, [
            { 
                id: "AwsSolutions-IAM5", 
                reason: "OpenSearch service-linked role creation requires wildcard permissions for specific service role ARN pattern. This is required by AWS for service-linked role management. See: https://docs.aws.amazon.com/opensearch-service/latest/developerguide/slr.html",
                appliesTo: ['Resource::arn:aws:iam::*:role/aws-service-role/opensearch.amazonaws.com/AWSServiceRoleForAmazonOpenSearchService']
            }
        ]);

        // Create OpenSearch service-linked role before creating the domain
        const openSearchServiceRoleFunction = new lambda.Function(this, "OpenSearchServiceRoleFunction", {
            code: lambda.Code.fromAsset(path.join(__dirname, './lambda')),
            handler: "opensearch_service_linked_role.lambda_handler",
            runtime: lambda.Runtime.PYTHON_3_14,
            timeout: cdk.Duration.minutes(5),
            description: "Custom resource Lambda function to create OpenSearch service-linked role",
            functionName: `${cdk.Stack.of(this).stackName}-opensearch-slr-lambda`,
            role: openSearchServiceRoleLambdaRole,
            logGroup: new logs.LogGroup(this, "OpenSearchServiceRoleLambdaLogGroup", {
                logGroupName: `/aws/lambda/${cdk.Stack.of(this).stackName}-opensearch-slr-lambda`,
                removalPolicy: cdk.RemovalPolicy.DESTROY,
            }),
        });

        // IAM role for custom resource provider with custom managed policy
        const openSearchServiceRoleProviderRole = new iam.Role(this, "OpenSearchServiceRoleProviderRole", {
            roleName: `${cdk.Stack.of(this).stackName}-${cdk.Stack.of(this).region}-opensearch-provider-role`,
            assumedBy: new iam.ServicePrincipal("lambda.amazonaws.com"),
            managedPolicies: [lambdaBasicExecutionPolicy],
            inlinePolicies: {
                LambdaInvokePolicy: new iam.PolicyDocument({
                    statements: [
                        new iam.PolicyStatement({
                            sid: "InvokeLambdaFunction",
                            effect: iam.Effect.ALLOW,
                            actions: ["lambda:InvokeFunction"],
                            resources: [openSearchServiceRoleFunction.functionArn]
                        })
                    ]
                })
            }
        });

        // Create custom resource provider for OpenSearch service-linked role
        const openSearchServiceRoleProvider = new customresource.Provider(this, "OpenSearchServiceRoleProvider", {
            onEventHandler: openSearchServiceRoleFunction,
            role: openSearchServiceRoleProviderRole,
            logGroup: new logs.LogGroup(this, "OpenSearchServiceRoleProviderLogs", {
                removalPolicy: cdk.RemovalPolicy.DESTROY
            })
        });

        // Add specific suppression for the Provider's DefaultPolicy resource with exact pattern matching
        cdk_nag.NagSuppressions.addResourceSuppressions(openSearchServiceRoleProvider, [
            { 
                id: "AwsSolutions-IAM5", 
                reason: "Custom resource provider DefaultPolicy requires wildcard permissions to invoke Lambda function versions. This is automatically generated by CDK for Lambda function versioning and aliases. The wildcard is scoped to the specific OpenSearch service role function ARN to maintain security while allowing version-specific invocations.",
                appliesTo: [
                    'Resource::<OpenSearchServiceRoleFunction*.Arn>:*',
                    'Resource::<OpenSearchServiceRoleFunction*>:*',
                    'Resource::<OpenSearchServiceRoleFunction45560A5A.Arn>:*'
                ]
            }
        ], true);

        // Direct suppression on the role's DefaultPolicy resource
        const defaultPolicy = openSearchServiceRoleProviderRole.node.tryFindChild('DefaultPolicy');
        if (defaultPolicy) {
            cdk_nag.NagSuppressions.addResourceSuppressions(defaultPolicy as cdk.CfnResource, [
                { 
                    id: "AwsSolutions-IAM5", 
                    reason: "Custom resource provider DefaultPolicy requires wildcard permissions to invoke Lambda function versions. This is automatically generated by CDK for Lambda function versioning and aliases. The wildcard is scoped to the specific OpenSearch service role function ARN to maintain security while allowing version-specific invocations.",
                    appliesTo: [
                        'Resource::<OpenSearchServiceRoleFunction45560A5A.Arn>:*'
                    ]
                }
            ]);
        }

        // Create the custom resource to ensure service-linked role exists
        const openSearchServiceLinkedRole = new cdk.CustomResource(this, 'OpenSearchServiceLinkedRole', {
            serviceToken: openSearchServiceRoleProvider.serviceToken,
            properties: {
                'Timestamp': Date.now() // Force update on each deployment if needed
            }
        });

        // Suppress CDK-Nag for OpenSearch service-linked role resources
        cdk_nag.NagSuppressions.addResourceSuppressions(openSearchServiceRoleFunction, [
            { id: "AwsSolutions-L1", reason: "Lambda function runtime for OpenSearch service-linked role creation is set to latest supported Python version." }
        ]);

        cdk_nag.NagSuppressions.addResourceSuppressions(openSearchServiceRoleProvider, [
            { id: "AwsSolutions-L1", reason: "Custom resource provider Lambda runtime is managed by CDK and cannot be customized." }
        ], true);

        // Create security group for OpenSearch domain
        const openSearchSecurityGroup = new ec2.SecurityGroup(this, 'OpenSearchSecurityGroup', {
            vpc: vpc,
            description: 'Security group for OpenSearch domain',
            allowAllOutbound: false,
        });

        // Allow HTTPS access from ECS tasks security group (will be created by the AI service)
        // We'll add this rule after the AI service is created

        // Create the OpenSearch Domain within VPC (depends on service-linked role)
        const domain = new opensearch.Domain(this, 'ProductsDomain', {
            domainName: `products-domain`,
            version: opensearch.EngineVersion.OPENSEARCH_2_11,
            capacity: {
                dataNodes: 3,
                dataNodeInstanceType: 'm6g.xlarge.search', // Choose instance type based on application preferences (i.e. cost/performance/etc.)
                masterNodes: 3,
                masterNodeInstanceType: 'm6g.xlarge.search', 
            },
            ebs: {
                volumeSize: 20,
                volumeType: ec2.EbsDeviceVolumeType.GP3,
            },
            zoneAwareness: {
                enabled: true,
                availabilityZoneCount: 3,
            },
            nodeToNodeEncryption: true,
            encryptionAtRest: {
                enabled: true,
            },
            // VPC configuration to place OpenSearch within the VPC
            vpc: vpc,
            vpcSubnets: [
                {
                    subnetType: ec2.SubnetType.PRIVATE_WITH_EGRESS,
                }
            ],
            securityGroups: [openSearchSecurityGroup],
            // Enable slow query logging for performance monitoring
            logging: {
                slowSearchLogEnabled: true,
                slowIndexLogEnabled: true,
                appLogEnabled: false, // Optional: application logs
                auditLogEnabled: false, // Optional: audit logs
            },
            // For VPC-based domains, access control is handled through security groups
            // rather than IP-based access policies
            accessPolicies: [
                new iam.PolicyStatement({
                    effect: iam.Effect.ALLOW,
                    actions: [
                        'es:ESHttpGet',
                        'es:ESHttpPost',
                        'es:ESHttpPut',
                        'es:ESHttpDelete',
                        'es:ESHttpHead',
                        'es:Describe*',
                        'es:List*'
                    ],
                    principals: [new iam.AccountRootPrincipal()],
                    resources: ['*'], // The CDK automatically scopes this to the domain's ARN
                }),
            ],
            removalPolicy: cdk.RemovalPolicy.DESTROY,
        });

        // Ensure the OpenSearch domain creation waits for the service-linked role
        domain.node.addDependency(openSearchServiceLinkedRole);

        // Suppress CDK-Nag for OpenSearch domain - access is restricted through VPC security groups
        cdk_nag.NagSuppressions.addResourceSuppressions(domain, [
            { id: "AwsSolutions-OS3", reason: "OpenSearch domain is deployed within VPC with security group restrictions. Access control is handled through security groups rather than IP-based policies, which is the recommended approach for VPC domains." }
        ]);

        // Apply NAG suppressions after all resources are created using CDK Aspects
        // This ensures suppressions are applied after the resources exist
        cdk.Aspects.of(this).add(new OpenSearchNagSuppressionsAspect());

        const ssmParameter = new ssm.StringParameter(this, "ApplicationParameters", {
            stringValue: JSON.stringify({
                "S3_BUCKET_NAME": bucket.bucketName,
                "FRONTEND_URL": this.Distribution.distributionDomainName,
                "OPENSEARCH_ENDPOINT": domain.domainEndpoint
            }),
            tier: ssm.ParameterTier.STANDARD,
            parameterName: `${cdk.Stack.of(this).stackName}-app-parameters`,
            description: "Parameters for React application.",
        })

        ssmParameter.grantRead(ecsTaskIamRole)

        // Create Fargate service for Web application
        const fargate = new ecs_patterns.ApplicationLoadBalancedFargateService(this, "WebService", {
            cluster: cluster,
            cpu: 2048,
            desiredCount: 1,
            loadBalancer: alb,
            openListener: false,
            assignPublicIp: true,
            taskImageOptions: {
                image: image,
                containerPort: 80,
                secrets: {
                    "AWS_RESOURCE_NAMES_PARAMETER": ecs.Secret.fromSsmParameter(ssmParameter),
                },
                taskRole: ecsTaskIamRole,
                executionRole: ecsTaskIamRole,
            },
            serviceName: `${cdk.Stack.of(this).stackName}-fargate`,
            memoryLimitMiB: 4096,
            publicLoadBalancer: true,
            enableExecuteCommand: true,
            platformVersion: ecs.FargatePlatformVersion.LATEST,
            runtimePlatform: {
                operatingSystemFamily: ecs.OperatingSystemFamily.LINUX,
                cpuArchitecture: ecs.CpuArchitecture.ARM64
            }
        })

        // Suppress CDK-Nag for auto-attach IAM policies
        cdk_nag.NagSuppressions.addResourceSuppressions(ecsTaskIamRole, [
            { id: "AwsSolutions-IAM5", reason: "ECS Task IAM role policy values are auto populated by CDK." },
        ], true)

        // Autoscaling task
        const scaling = fargate.service.autoScaleTaskCount({ maxCapacity: 3 })
        scaling.scaleOnCpuUtilization('Scaling', {
            targetUtilizationPercent: 50,
            scaleInCooldown: cdk.Duration.seconds(60),
            scaleOutCooldown: cdk.Duration.seconds(60)
        })

        // AI Python App (Strands SDK), using CDK construct
        const ai = new AiService(this, "Ai", {
            vpc,
            cluster,
            alb,
            albSecurityGroup: elbSg,
            apiPathPattern: "/api/*",
            containerPort: 8000,            // FastAPI port
            cpuArch: ecs.CpuArchitecture.ARM64, // match with container image
            ssmParameter: ssmParameter,
        });

        // Allow AI service to access OpenSearch domain
        openSearchSecurityGroup.addIngressRule(
            ec2.Peer.securityGroupId(ai.service.connections.securityGroups[0].securityGroupId),
            ec2.Port.tcp(443),
            'Allow HTTPS access from AI service'
        );

        // ALB rules
        // Rule to catch API traffic, higher precedence (lower number) than the web catch-all below 
        fargate.listener.addTargetGroups("ApiRule", {
            priority: 10,
            conditions: [
                elb.ListenerCondition.httpHeader("Header", ["PRIVATE_ACCESS"]),
                elb.ListenerCondition.pathPatterns(["/api/*"]),
            ],
            targetGroups: [ai.targetGroup],
        });

        // Rule to catch all non-API traffic coming from CloudFront, send to web app service 
        fargate.listener.addAction("WebCatchAll", {
            priority: 100,
            conditions: [elbv2.ListenerCondition.httpHeader("Header", ["PRIVATE_ACCESS"])],
            action: elbv2.ListenerAction.forward([fargate.targetGroup]),
        });

        // DynamoDB tables
        const customers = new dynamodb.Table(this, 'CustomersTable', {
            tableName: 'customers',
            billingMode: dynamodb.BillingMode.PAY_PER_REQUEST,
            partitionKey: { name: 'customer_id', type: dynamodb.AttributeType.STRING },
            encryption: dynamodb.TableEncryption.AWS_MANAGED,
            pointInTimeRecovery: true,
            removalPolicy: cdk.RemovalPolicy.DESTROY, // change to RETAIN for prod
        });

        const products = new dynamodb.Table(this, 'ProductsTable', {
            tableName: 'products',
            billingMode: dynamodb.BillingMode.PAY_PER_REQUEST,
            partitionKey: { name: 'id', type: dynamodb.AttributeType.STRING },
            encryption: dynamodb.TableEncryption.AWS_MANAGED,
            pointInTimeRecovery: true,
            removalPolicy: cdk.RemovalPolicy.DESTROY, // change to RETAIN for prod
        });

        products.addGlobalSecondaryIndex({
            indexName: 'category-index',
            partitionKey: { name: 'category', type: dynamodb.AttributeType.STRING },
            sortKey: { name: 'price', type: dynamodb.AttributeType.NUMBER },
            projectionType: dynamodb.ProjectionType.ALL,
        });

        const searchHistory = new dynamodb.Table(this, 'SearchHistoryTable', {
            tableName: 'search_history',
            billingMode: dynamodb.BillingMode.PAY_PER_REQUEST,
            partitionKey: { name: 'search_id', type: dynamodb.AttributeType.STRING },
            encryption: dynamodb.TableEncryption.AWS_MANAGED,
            pointInTimeRecovery: true,
            removalPolicy: cdk.RemovalPolicy.DESTROY, // change to RETAIN for prod
        });

        const orders = new dynamodb.Table(this, 'OrdersTable', {
            tableName: 'orders',
            billingMode: dynamodb.BillingMode.PAY_PER_REQUEST,
            partitionKey: { name: 'order_id', type: dynamodb.AttributeType.STRING },
            encryption: dynamodb.TableEncryption.AWS_MANAGED,
            pointInTimeRecovery: true,
            removalPolicy: cdk.RemovalPolicy.DESTROY, // change to RETAIN for prod
        });

        orders.addGlobalSecondaryIndex({
            indexName: 'customer-index',
            partitionKey: { name: 'customer_id', type: dynamodb.AttributeType.STRING },
            sortKey: { name: 'order_date', type: dynamodb.AttributeType.STRING },
            projectionType: dynamodb.ProjectionType.ALL,
        });

        this.addTags()
        this.addOutputs(domain)
    }

    private addTags() {
        cdk.Tags.of(this).add("project", "Guidance for Building Hyper-Personalized Customer Experience powered by Agentic AI on AWS")
        cdk.Tags.of(this).add("repo", "https://github.com/aws-solutions-library-samples/guidance-for-building-agentic-ai-powered-hyper-personalized-customer-experience-on-aws")
    }

    private addOutputs(domain: opensearch.Domain) {
        new cdk.CfnOutput(this, "ReactUrl", {
            value: `https://${this.Distribution.distributionDomainName}`,
            description: 'The CloudFront distribution URL for the React application',
        }); 
        new cdk.CfnOutput(this, "S3 Bucket (Images)", {
            value: `${cdk.Stack.of(this).stackName.toLowerCase()}-data-source-${cdk.Aws.ACCOUNT_ID}-${cdk.Aws.REGION}`,
            description: 'S3 bucket containing product images',
        }); 
        new cdk.CfnOutput(this, 'OpenSearchDomainEndpoint', {
            value: domain.domainEndpoint,
            description: 'The endpoint for the OpenSearch domain',
        });
        new cdk.CfnOutput(this, 'AwsRegion', {
            value: cdk.Stack.of(this).region,
            description: 'The AWS region where resources are deployed',
        });
        new cdk.CfnOutput(this, 'DynamoDbCustomersTable', {
            value: 'customers',
            description: 'The name of the DynamoDB customers table',
        });
        new cdk.CfnOutput(this, 'DynamoDbProductsTable', {
            value: 'products',
            description: 'The name of the DynamoDB products table',
        });
        new cdk.CfnOutput(this, 'DynamoDbSearchHistoryTable', {
            value: 'search_history',
            description: 'The name of the DynamoDB search history table',
        });
        new cdk.CfnOutput(this, 'DynamoDbOrdersTable', {
            value: 'orders',
            description: 'The name of the DynamoDB orders table',
        });
        new cdk.CfnOutput(this, 'OpenSearchIndexName', {
            value: 'products',
            description: 'The name of the OpenSearch index',
        });
    }
}
